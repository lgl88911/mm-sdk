#!/usr/bin/python3
# -*- coding: UTF-8 -*-

import os, sys
import argparse
import toml
import subprocess
from pathlib import Path

g_ProjectPath = ''
g_BuildPath = ''
g_SdkPath = ''
g_CHeader = ''
g_ProjectName = ''
g_ToolBase = ''
g_SearchPaths = []
g_Verbose = False

defaultExeToml = """# This is a TOML document generated by MadBuild.

board = "SwiftIOBoard"
type = "executable"
dependencies = [
    "SwiftIO",
]"""

defaultLibToml = """# This is a TOML document generated by MadBuild.

board = "SwiftIOBoard"
type = "library"
dependencies = [
    "SwiftIO",
]"""


def generateToml(name, type):
    ret = sorted(Path('.').glob('*.mmswift'))

    if ret:
        print('Project ' + ret[0].name + ' already exist, initiaization failed!')
        os._exit(-1)

    Path('./' + name + '.mmswift').touch(exist_ok = True)
    if type == 'lib':
        Path('./' + name + '.mmswift').write_text(defaultLibToml)
        Path('./Sources/' + name + '/' + name + '.swift').touch(exist_ok = True)
    else:
        Path('./' + name + '.mmswift').write_text(defaultExeToml)
        Path('./Sources/' + name + '/main.swift').touch(exist_ok = True)


def initProject(args):
    if args.name:
        name = args.name
    else:
        name = Path('.').resolve().name

    src = Path('./Sources') / name
    src.mkdir(parents = True, exist_ok = True)
    generateToml(name, args.type)

    os._exit(0)


def parseTOML():
    ret = sorted(g_ProjectPath.glob('*.mmswift'))

    if ret:
        name = ret[0].stem
        tomlString = ret[0].read_text()
        if tomlString:
            try:
                tomlDic = toml.loads(tomlString)
            except:
                print('Project file ' + ret[0].name + ' decoding failed!')
                os._exit(-1)
        else:
            ret[0].write_text(defaultExeToml)
            tomlDic = toml.loads(defaultExeToml)
        tomlDic['name'] = name
        return tomlDic

    print('Error: Can not find project file!')
    os._exit(-1)
    


def cleanBuild():
    files =  sorted(g_BuildPath.glob('*.bin'))
    files += g_BuildPath.glob('*.elf')
    files += g_BuildPath.glob('*.map')
    files += g_BuildPath.glob('*.a')
    files += g_BuildPath.glob('*.o*')
    files += g_BuildPath.glob('*.c')
    files += g_BuildPath.glob('*.swiftmodule')
    files += g_BuildPath.glob('*.swiftdoc')
    for file in files:
        file.unlink()
    return



def getSDKTool(tool):
    value = ''
    if tool == 'swiftc':
        value = (g_SdkPath / g_ToolBase / 'toolchains/swift/bin/swiftc')
    elif tool == 'stdPath':
        value = (g_SdkPath / g_ToolBase / 'toolchains/swift/lib/swift/zephyr/thumbv7em')
    elif tool == 'ar':
        value = (g_SdkPath / g_ToolBase / 'toolchains/gcc/bin/arm-none-eabi-ar')
    elif tool == 'gcc':
        value = (g_SdkPath / g_ToolBase / 'toolchains/gcc/bin/arm-none-eabi-gcc')
    elif tool == 'gpp':
        value = (g_SdkPath / g_ToolBase / 'toolchains/gcc/bin/arm-none-eabi-g++')
    elif tool == 'objcopy':
        value = (g_SdkPath / g_ToolBase / 'toolchains/gcc/bin/arm-none-eabi-objcopy')
    elif tool == 'gen_isr_tables':
        value = (g_SdkPath / g_ToolBase / 'scripts/dist/gen_isr_tables/gen_isr_tables')
    return value


def compileSwift(target):
    cmd = '"%s"' % str(getSDKTool('swiftc'))

    swiftFlags = [
        '-module-name ' + g_ProjectName,
        '-target thumbv7em-none--eabi',
        '-target-cpu cortex-m7',
        '-target-fpu fpv5-dp-d16',
        '-float-abi soft',
        #'-parse-as-library',
        '-O',
        '-static-stdlib',
        '-function-sections',
        '-data-sections',
        '-Xcc -D__ZEPHYR__',
        '-Xfrontend -assume-single-threaded',
        '-no-link-objc-runtime'
    ]

    if target == 'module':
        swiftFlags.insert(0, '-parse-as-library')
        swiftFlags.insert(0, '-emit-module')
    elif target == 'object':
        swiftFlags.insert(0, '-parse-as-library')
        swiftFlags.insert(0, '-c')
    elif target == 'exe':
        swiftFlags.insert(0, '-c')
    else:
        os._exit(-1)

    if g_CHeader: 
        swiftFlags.append('-import-objc-header ' + '"%s"' % str(g_CHeader))

    for item in g_SearchPaths:
        swiftFlags.append('-I ' + '"%s"' % str(item))

    swiftFiles = sorted((g_ProjectPath / 'Sources' / g_ProjectName).rglob("*.swift"))
    for file in swiftFiles:
        swiftFlags.append('"%s"' % str(file))

    for item in swiftFlags:
        cmd += ' ' + item

    os.chdir(g_BuildPath)
    if g_Verbose:
        print(cmd)
    p = subprocess.Popen(cmd, shell = True)
    p.wait()
    return p.poll()


def mergeObjects():
    cmd = '"%s"' % str(getSDKTool('ar'))

    arFlags = [
        '-rcs'
    ]

    targetName = '"%s"' % str(g_BuildPath / ('lib' + g_ProjectName + '.a'))
    arFlags.append(targetName)

    files = sorted(g_BuildPath.glob("*.o"))
    for file in files:
        arFlags.append('"%s"' % str(file))

    for item in arFlags:
        cmd += ' ' + item

    os.chdir(g_BuildPath)
    if g_Verbose:
        print(cmd)
    p = subprocess.Popen(cmd, shell = True)
    p.wait()
    return p.poll()

def linkELF(step):
    cmd = '"%s"' % str(getSDKTool('gpp'))

    flags = [
        '-mcpu=cortex-m7',
        '-mthumb',
        '-mfpu=fpv5-d16',
        '-mfloat-abi=soft',
        '-mabi=aapcs',
        '-nostdlib',
        '-static',
        '-no-pie',
        '-Wl,-u,_OffsetAbsSyms',
        '-Wl,-u,_ConfigAbsSyms',
        #'-Wl,--print-memory-usage',
        '-Wl,-X',
        '-Wl,-N',
        '-Wl,--gc-sections',
        '-Wl,--build-id=none',
        '-Wl,--sort-common=descending',
        '-Wl,--sort-section=alignment',
        '-Wl,--no-enum-size-warning',
        #'-Wl,--strip-all',
        #'-Wl,--orphan-handling=warn',
        #'-Wl,-Map=' + buildFolder + '/' + g_ProjectName + '.map',
        #halPath + '/generated/empty_file.c.obj'
    ]

    if step == 'step2':
        mapTarget = '"%s"' % str(g_BuildPath / g_ProjectName / '.map')
        flags.append('-Wl,-Map=' + mapTarget)
        flags.append('-Wl,--print-memory-usage')
        linkScript = '"%s"' % str(g_SdkPath / 'hal/HalSwiftIOBoard/generated/linker_pass_final.cmd')
        flags.append('-Wl,-T ' + linkScript)
        flags.append('"%s"' % str(g_BuildPath / 'isr_tables.c.obj'))
    elif step == 'step1':
        linkScript = '"%s"' % str(g_SdkPath / 'hal/HalSwiftIOBoard/generated/linker.cmd')
        flags.append('-Wl,-T ' + linkScript)  
        flags.append('"%s"' % str(g_SdkPath / 'hal/HalSwiftIOBoard/generated/empty_file.c.obj'))
    
    flags.append('-L' + '"%s"' % str(g_SdkPath / g_ToolBase / 'toolchains/gcc/arm-none-eabi/lib/thumb/v7e-m'))
    flags.append('-L' + '"%s"' % str(g_SdkPath / g_ToolBase / 'toolchains/gcc/lib/gcc/arm-none-eabi/7.3.1/thumb/v7e-m'))

    flags.append('-Wl,--whole-archive')
    flags.append('"%s"' % str(g_SdkPath / g_ToolBase / 'toolchains/swift/lib/swift/zephyr/thumbv7em/swiftrt.o'))
    flags.append('"%s"' % str(g_BuildPath / ('lib' + g_ProjectName + '.a')))

    librarFiles = sorted((g_SdkPath / 'hal/HalSwiftIOBoard/generated/whole').rglob("*.a"))
    for file in librarFiles:
        flags.append('"%s"' % str(file))

    flags.append('-Wl,--no-whole-archive')

    if step == 'step1':
        #g_SearchPaths.append(g_BuildPath)
        g_SearchPaths.append(g_SdkPath / 'hal/HalSwiftIOBoard/generated/no_whole')

    print(g_SearchPaths)

    flags.append('-Wl,--start-group')
    for item in reversed(g_SearchPaths):
        files = sorted(item.glob("*.a"))
        for file in files:
            flags.append('"%s"' % str(file))

    
    flags += [
        #'-Wl,--start-group',
        '-lgcc',
        '-lstdc++',
        '-lm',
        '-lc',
        '-Wl,--end-group',
        '-o'
    ]

    if step == 'step1':
        flags.append('"%s"' % str(g_BuildPath / (g_ProjectName + '_prebuilt.elf')))
    elif step == 'step2':
        flags.append('"%s"' % str(g_BuildPath / (g_ProjectName + '.elf')))

    for item in flags:
        cmd += ' ' + item

    os.chdir(g_BuildPath)
    if g_Verbose:
        print(cmd)
    p = subprocess.Popen(cmd, shell = True)
    p.wait()
    return p.poll()

def buildLibrary():
    if compileSwift('module'):
        os._exit(-1)
    if compileSwift('object'):
        os._exit(-1)
    if mergeObjects():
        os._exit(-1)

def buildExecutable():
    if compileSwift('exe'):
        os._exit(-1)
    if mergeObjects():
        os._exit(-1)
    if linkELF('step1'):
        os._exit(-1)
    return

def buildProject(args):
    global g_ProjectPath
    global g_BuildPath
    global g_SdkPath

    global g_SearchPaths

    global g_ProjectName
    global g_ToolBase
    global g_CHeader
    global g_Verbose

    g_ProjectPath = Path('.').resolve()
    g_BuildPath = Path('.build').resolve()
    g_SdkPath = Path(args.sdk).resolve()
    print(g_SdkPath)

    if args.header:
        g_CHeader = Path(args.header).resolve()

    if args.g_Verbose:
        g_Verbose = True

    if sys.platform.startswith('darwin'):
        g_ToolBase = 'tools_mac'
    elif sys.platform.startswith('win'):
        g_ToolBase = 'tools_win'
    elif sys.platform.startswith('linux'):
        g_ToolBase = 'tools_linux'

    if args.module:
        modulePath = Path(args.module).resolve()
    else:
        modulePath = (Path.home() / 'Documents' / 'MadMachine' / 'Library').resolve()


    # Parse name, type, dependencies
    tomlDic = parseTOML()
    g_ProjectName = tomlDic['name']
    for module in tomlDic['dependencies']:
        g_SearchPaths.append(modulePath / module / '.build')

    g_SearchPaths.append(getSDKTool('stdPath'))

    g_BuildPath.mkdir(exist_ok = True)
    cleanBuild()

    if tomlDic['type'] == 'library':
        buildLibrary()
    elif tomlDic['type'] == 'executable':
        buildExecutable()


def initArgs():
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers()

    initParser = subparsers.add_parser('init', help = 'Initiaize a new project. If not specified, project name depends on the current directory name')
    initParser.add_argument('-n', '--name', type = str, help = 'Initiaize a new project with given name')
    initParser.add_argument("-t", "--type", type = str, choices = ['exe', 'lib'], default = 'exe', help = "Project type, default type is executable")
    initParser.set_defaults(func = initProject)

    buildParser = subparsers.add_parser('build', help = 'Build a project, build type(executable/library) depends on the project file')
    buildParser.add_argument("--sdk", type = str, required = True, help = "SDK path")
    buildParser.add_argument("--module", type = str, help = "Swift module search path")
    buildParser.add_argument("--header", type = str, help = "C header file")
    buildParser.add_argument("-v", "--g_Verbose", action = 'store_true', help = "Increase output verbosity")
    buildParser.set_defaults(func = buildProject)

    args = parser.parse_args()
    args.func(args)


if __name__ == '__main__':
    initArgs()