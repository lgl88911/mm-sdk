#!/usr/bin/python3
# -*- coding: UTF-8 -*-

import os, sys
import argparse
import toml
import subprocess
from pathlib import Path

buildPath = Path()
sdkPath = Path()
searchPaths = []
swiftFiles = []

projectName = ''
toolBase = ''
cHeader = ''
verbose = False

defaultExeToml = """# This is a TOML document generated by MadBuild.

board = "SwiftIOBoard"
type = "executable"
dependencies = [
    "SwiftIO",
]"""

defaultLibToml = """# This is a TOML document generated by MadBuild.

board = "SwiftIOBoard"
type = "library"
dependencies = [
    "SwiftIO",
]"""


def generateToml(type):
    ret = sorted(Path('.').glob('*.mmswift'))

    if ret:
        print('Project ' + ret[0].name + ' already exist, initiaization failed!')
        os._exit(-1)

    Path('./' + projectName + '.mmswift').touch(exist_ok = True)
    if type == 'lib':
        Path('./' + projectName + '.mmswift').write_text(defaultLibToml)
        Path('./Sources/' + projectName + '/' + projectName + '.swift').touch(exist_ok = True)
    else:
        Path('./' + projectName + '.mmswift').write_text(defaultExeToml)
        Path('./Sources/' + projectName + '/main.swift').touch(exist_ok = True)


def initProject(args):
    global projectName

    if args.name:
        projectName = args.name
    else:
        projectName = Path('.').resolve().name

    src = Path('./Sources/' + projectName)
    src.mkdir(parents = True, exist_ok = True)
    generateToml(args.type)

    os._exit(0)


def parseTOML():
    ret = sorted(Path('.').glob('*.mmswift'))

    if ret:
        projectName = ret[0].stem
        tomlString = ret[0].read_text()
        if tomlString:
            try:
                tomlDic = toml.loads(tomlString)
            except:
                print('Project file ' + ret[0].name + ' decoding failed!')
                os._exit(-1)
        else:
            ret[0].write_text(defaultExeToml)
            tomlDic = toml.loads(defaultExeToml)
        tomlDic['name'] = projectName
        return tomlDic

    print('Error: Can not find project file!')
    os._exit(-1)
    


def cleanBuild():
    files =  sorted(buildPath.glob('*.bin'))
    files += buildPath.glob('*.elf')
    files += buildPath.glob('*.map')
    files += buildPath.glob('*.a')
    files += buildPath.glob('*.o*')
    files += buildPath.glob('*.c')
    files += buildPath.glob('*.swiftmodule')
    files += buildPath.glob('*.swiftdoc')
    for file in files:
        file.unlink()
    return



def getSDKTool(tool):
    value = ''
    if tool == 'swiftc':
        value = toolBase + 'toolchains/swift/bin/swiftc'
    elif tool == 'stdPath':
        value = toolBase + 'toolchains/swift/lib/swift/zephyr/thumbv7em'
    elif tool == 'ar':
        value = toolBase + 'toolchains/gcc/bin/arm-none-eabi-ar'
    elif tool == 'gcc':
        value = toolBase + 'toolchains/gcc/bin/arm-none-eabi-gcc'
    elif tool == 'gpp':
        value = toolBase + 'toolchains/gcc/bin/arm-none-eabi-g++'
    elif tool == 'objcopy':
        value = toolBase + 'toolchains/gcc/bin/arm-none-eabi-objcopy'
    elif tool == 'gen_isr_tables':
        value = toolBase + 'scripts/dist/gen_isr_tables/gen_isr_tables'
    return value


def compileSwift(targetPath, target):
    cmd = str(sdkPath / getSDKTool('swiftc'))

    swiftFlags = [
        '-module-name ' + projectName,
        '-target thumbv7em-none--eabi',
        '-target-cpu cortex-m7',
        '-target-fpu fpv5-dp-d16',
        '-float-abi soft',
        #'-parse-as-library',
        '-O',
        '-static-stdlib',
        '-function-sections',
        '-data-sections',
        '-Xcc -D__ZEPHYR__',
        '-Xfrontend -assume-single-threaded',
        '-no-link-objc-runtime'
    ]

    if target == 'module':
        swiftFlags.insert(0, '-parse-as-library')
        swiftFlags.insert(0, '-emit-module')
    elif target == 'object':
        swiftFlags.insert(0, '-parse-as-library')
        swiftFlags.insert(0, '-c')
    elif target == 'exe':
        swiftFlags.insert(0, '-c')
    else:
        os._exit(-1)

    if cHeader: 
        swiftFlags.append('-import-objc-header ' + str(cHeader.resolve()))
    
    for item in searchPaths:
        swiftFlags.append('-I ' + str(item))

    for file in swiftFiles:
        swiftFlags.append(str(file.resolve()))

    for item in swiftFlags:
        cmd += ' ' + item

    os.chdir(targetPath.resolve())
    if verbose:
        print(cmd)
    p = subprocess.Popen(cmd, shell = True)
    p.wait()
    return p.poll()

def buildLibrary():
    if compileSwift(buildPath, 'module'):
        os._exit(-1)
    if compileSwift(buildPath, 'object'):
        os._exit(-1)

def buildExecutable():
    return

def buildProject(args):
    global buildPath
    global sdkPath
    global swiftFiles
    global searchPaths

    global projectName
    global toolBase
    global cHeader
    global verbose

    # Parse name, type, dependencies
    tomlDic = parseTOML()
    print(tomlDic)
    projectName = tomlDic['name']


    buildPath = Path('.build')
    buildPath.mkdir(exist_ok = True)
    cleanBuild()

    sdkPath = Path(args.sdk)

    if sys.platform.startswith('darwin'):
        toolBase = 'tools_mac/'
    elif sys.platform.startswith('win'):
        toolBase = 'tools_win/'
    elif sys.platform.startswith('linux'):
        toolBase = 'tools_linux/'

    if args.header:
        cHeader = Path(args.header)

    swiftFiles = sorted(Path('./Sources/' + projectName).rglob("*.swift"))

    if args.module:
        modulePath = Path(args.module)
    else:
        modulePath = Path.home() / 'Documents' / 'MadMachine' / 'Library'

    print(modulePath)

    for module in tomlDic['dependencies']:
        searchPaths.append(modulePath / module / '.build')

    searchPaths.append(sdkPath / getSDKTool('stdPath'))
    
    print(searchPaths)

    if args.verbose:
        verbose = True

    if tomlDic['type'] == 'library':
        buildLibrary()
    elif tomlDic['type'] == 'executable':
        buildExecutable()


def initArgs():
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers()

    initParser = subparsers.add_parser('init', help = 'Initiaize a new project. If not specified, project name depends on the current directory name')
    initParser.add_argument('-n', '--name', type = str, help = 'Initiaize a new project with given name')
    initParser.add_argument("-t", "--type", type = str, choices = ['exe', 'lib'], default = 'exe', help = "Project type, default type is executable")
    initParser.set_defaults(func = initProject)

    buildParser = subparsers.add_parser('build', help = 'Build a project, build type(executable/library) depends on the project file')
    buildParser.add_argument("--sdk", type = str, required = True, help = "SDK path")
    buildParser.add_argument("--module", type = str, help = "Swift module search path")
    buildParser.add_argument("--header", type = str, help = "C header file")
    buildParser.add_argument("-v", "--verbose", action = 'store_true', help = "Increase output verbosity")
    buildParser.set_defaults(func = buildProject)

    args = parser.parse_args()
    args.func(args)


if __name__ == '__main__':
    initArgs()